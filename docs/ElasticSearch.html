<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" type="text/css" media="screen" href="normalize.css">
    <!--
    <link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel="stylesheet">
    -->
    <link rel="stylesheet" type="text/css" media="screen" href="site.css">
  </head>

  <body>
      <div class="container wrapper post">
      <div class="header">
          <h1 class="site-title"><a href="index.html">Brain Dump</a></h1>
          <div class="site-description">
              <h2>DistributedSystems</h2>
          </div>
          <nav class="nav">
              <ul class="flat">
                <li> <a href="index.html">Home</a></li>
                <li> <a href="listing.html">All posts</a></li>

              </ul>
          </nav>

    </div>


    <div class="post-header">
        <h1 class="title">ElasticSearch</h1>
        <div class="meta">Updated at: 2019-06-26 14:37:16.88636707 +0800 +08</div>
    </div>
    <div class="markdown">

          

<p>Elasticsearch is a distributed RESTful search engine.
- Search engine where each index has a fully configurable number of shards.
- Each shard has one or more replicas
- Read/search operation in replica</p>

<p>Built on top of Lucene</p>

<p>Multi Tenant
- Support for &gt; 1 index
- Index level configuration</p>

<p>Set of APIs
- HTTP RESTful API
- Native Java API</p>

<p>Document oriented
- No need for upfront schema definition
- Schema can be defined for customizing indexing process</p>

<h2>Key concepts</h2>

<ol>
<li>Near Realtime</li>
</ol>

<p>There is about a 1 sec latency from indexing to searching</p>

<ol>
<li>Cluster</li>
</ol>

<p>Collection of one or more ndoes that holds data, provides federated indexing and search capabilities across all nodes.
Cluster identified by unique name, and node joins a cluster only through name</p>

<ol>
<li>Node</li>
</ol>

<p>Single server in cluster, stores data, participates in indexing and search. Node identified by random UUID.</p>

<ol>
<li>Index</li>
</ol>

<p>Index is a collection of docs w similar characteries, identified by name</p>

<ol>
<li>Type</li>
</ol>

<p>Logical category/partition of index to allow one to store diff type of documents in the index (to be deprecated)</p>

<ol>
<li>Document</li>
</ol>

<p>Expressed as JSON</p>

<ol>
<li>Shards and replicas</li>
</ol>

<p>Sharding allows one to horizontally split/scale content. Allows one to distribute and parallelize operations across shards. When you create an index, one can simply define the number of shards that one wants.</p>

<p>Each shard is a fully functional index.</p>

<h2>Lucene</h2>

<p>High performance, full-featured text search engine.</p>

<p>150GB/hour with small RAM requirements (1MB heap)</p>

<p>About 20%/30% of size</p>

<p>Implements efficient search algorithms, available open source under Apache license</p>

<h2>Reading Documents</h2>

<h3>Data replication model</h3>

<p>Each index is divided into shards, and each shard has multiple copies. Each copy is a replacation group and kept in sync.</p>

<p>Data replication is based on the primary-backup model, and described well in PacificA paper of microsoft research. Single copy of replication group that acts as primary shard, the other copies are replication shards.</p>

<p>Primary is responsible for replicating operation to other copies.</p>

<h2>Basic write model</h2>

<p>Every indexing is resolved using routing, typically based on document ID.</p>

<h2>Routing</h2>

<p>Routing is controlled using the hash of document ID&rsquo;s value.</p>

<p>For explicit control, value fed into the hash function used by router can be directly specified on a per-operation basis.</p>

<p>When setting up explicit mapping, _routing field can be optionally used to direct the index operation.</p>

<h2>Basic Write Model</h2>

<p>Every indexing operation is resolved to a replication group using routing. (Refer to above). Once replicatino group determined, the operation is forwarded to the primary shard. Primary shard validates the operation and forwards it to the replcias.</p>

<p>List is called in-sync copies and is maintained by the master node.</p>

<p>The primary shard follows this basic flow:</p>

<p>Validate incoming operation and reject it if structurally invalid (Example: have an object field where a number is expected)
Execute the operation locally i.e. indexing or deleting the relevant document. This will also validate the content of fields and reject if needed (Example: a keyword value is too long for indexing in Lucene).
Forward the operation to each replica in the current in-sync copies set. If there are multiple replicas, this is done in parallel.
Once all replicas have successfully performed the operation and responded to the primary, the primary acknowledges the successful completion of the request to the client.</p>

<h2>Write failuer</h2>

<p>In the case that the primary itself fails, node hosting primaru will send message to master. Indexing operation will wait for master to promote one of the copies to be primary.</p>

<h2>Basic Read Model</h2>

<p>When a read request is received by a node, that node is responsible for forwarding it to the nodes that hold the relevant shards, collating the responses, and responding to the client. We call that node the coordinating node for that request. The basic flow is as follows:</p>

<p>Resolve the read requests to the relevant shards. Note that since most searches will be sent to one or more indices, they typically need to read from multiple shards, each representing a different subset of the data.
Select an active copy of each relevant shard, from the shard replication group. This can be either the primary or a replica. By default, Elasticsearch will simply round robin between the shard copies.
Send shard level read requests to the selected copies.
Combine the results and respond. Note that in the case of get by ID look up, only one shard is relevant and this step can be skipped.</p>

<h2>Distributed</h2>

<h3>Wait for active shards</h3>

<p>Indexing oeprations can be configured to wait for a certain nunmber of active shard copies before proceeding with the operation. If the requisite number of active shard copies are not available, then the write operation must wait and retry.</p>

<p>Write operations can work on the primary but fail on the replicated nodes.</p>

<h2>Refresh</h2>

<p>Refresh controls when changes made by the request are made available to search.</p>

<h2>API</h2>

<h2>Search API</h2>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-search-API.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-search-API.html</a></p>

<h2>Search Shard API</h2>

<p>Returns the indices and shards that a search request would be executed against.</p>

<p>Sequence number and primary term uniquely identify a change.</p>

<p>preference: which shard replicas to execute the search request on. (By default, randomized, between requests)</p>

<p>local: boolean value to indicate whether to read state locally or use master nodes cluster state.</p>

<p>cross-field queries: term centric approach by blending idfs, searches for matches across all fields</p>

<p>BoolQueries:
A query that matches documents matching boolean combinations of other queries.</p>

<p>Built using 1 or more boolean clauses, which each clause mapping to a typed occurence.</p>

<h2>A note about Indexing</h2>

<p>An elasticsearch cluster can contain multiple <em>indices</em>, which in turn contain multiple <em>types</em>. These types hold multiple documents, and each document has multiple <em>fields</em>.</p>

<h2>Index lifecycle</h2>

<p>There are four stages in the index life cycle.</p>

<ol>
<li>Hot - index being updated and queried</li>
<li>Warm - index no longer being updated, still being queried</li>
<li>Cold - no longer being updated and is seldom queried.</li>
<li>Delete - index is no longer needed and can be safely deleted</li>
</ol>

<p>Lifecycle policy governs index transitions through these stages:
1. Maximum size or age at which we want to roll over to new index
2. Point that index is no longer being udpdated
3. When to force merge, permanently delete documents
4. Index deletion</p>

<h2>Document Orientated</h2>

<p>Objects are complete data structures that may contain dates, geo locations, other objects, arrays</p>

<p>These objects are stored and indexed to be searchable. JSON is used as all languages support it.</p>

<p>Converting object to JSON to be indexed is simpler than converting JSON to flat table.</p>

<p>Document has metadata. The three required metadata:</p>

<ol>
<li><p>_index: where the document lives</p></li>

<li><p>_type: class of object that document represents</p></li>

<li><p>_index: collection of documents that should be grouped together for a common reason</p></li>
</ol>

<h2>Mapping</h2>

<p>Mapping is the process of defining how a document, and the fields in contains, are stored and indexed. For instance, use mappings to define:</p>

<ol>
<li>Which string fields should be treated as full text fields</li>
<li>Which fields contains numbers, dates, geolocations</li>
<li>Format of date values</li>
<li>Custom rules to control mapping for dynamically added fields</li>
</ol>

<p>Each index has a mapping type to determine how the document will be indexed.</p>

<p>Mapping type has:
	- Meta-fields: used to customized how a document&rsquo;s meta data asscociated and treated</p>

<pre><code>- Fields or properties: Contains list of fields or properties pertinent to the document
</code></pre>

<p>Settings to prevent mappings explosion:</p>

<p>Too many fields in an index is a condition that can lead to mapping explosion, which can cause out of memory errors and difficult situations to recover from. This problem may be more common than expected. Consider where every new document inserted introduces new fields.</p>

<h2>Creating and Updating a document</h2>

<p>When sending a PUT request and if a document with the same _index, _type, _id exists,
	1. If ?op_type=create is present, then  the request will be rejected with a <em>409 Conflict</em> response code
	2. If it is not present, new document will be created with a higher version number, older document is rejected</p>

<p>We are also able to partially update the document using _update. Scripting using Groovy is also supported.</p>

<h2>Concurrency Control</h2>

<p>The most recent request wins in ES.
Preventing race condition when updating values in index.</p>

<h3>Pessimistic Concurrency Control</h3>

<p>Used in relational databases, assumes conflicting changes are likely to happen. Blocl access to a resource in order ot prevent conflicts. i.e. locking a row before reading data, ensuring only the thread that place the lock is able to make changes.</p>

<h3>Optimistic Concurrency Control</h3>

<p>Used in ES, assumes conflicts are unliekely to happen, doesn&rsquo;t block.
However, if underlying data has been modified between reading and writing, the update will fail. Then up to application to decide how to resolve the conflict.</p>

<p>ES is async and concurrent, meaning that requests may arrive at destination <em>out of sequence</em>. Versions change at every document change, and ES uses version to ensure changes are applied in the correct order. i.e. if an old document arrives after new, it can be ignored.</p>

<p><em>This requires the user to retrieve a copy if the document to get its version number, before reindexing the document with the version number of the document that it shuold ne applied to</em>.</p>

<p>Note that an external data store can be used. By specifiying version_type=external parameter, ES checks that the current version is less than specified version.</p>

<h2>Distributed Document Store</h2>

<p>When a document is indexed, it is stored on a single primary shard.</p>

<p>Routing can be used direct requests to the right shard.</p>

<h3>Store</h3>

<p>Allows one to control how index data is stored and accessed on disk</p>

<p><em>fs</em>:
	Default file system implementation. Pick best implementation depending on the OS.</p>

<p><em>simplefs</em>:
	Straightforward implementation of file system storage</p>

<p><em>niofs</em>:
	Stores the shard index on the file system</p>


    </div>
</div>
    <div class="footer">
        by <a href="https://pengnam.github.io">Sean Ng</a> | <a href="https://github.com/pengnam/BrainDump">source</a>
  </div>
  </body>
</html>
