<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" type="text/css" media="screen" href="normalize.css">
    <!--
    <link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel="stylesheet">
    -->
    <link rel="stylesheet" type="text/css" media="screen" href="site.css">
  </head>

  <body>
      <div class="container wrapper post">
      <div class="header">
          <h1 class="site-title"><a href="index.html">Brain Dump</a></h1>
          <div class="site-description">
              <h2>Algorithms</h2>
          </div>
          <nav class="nav">
              <ul class="flat">
                <li> <a href="index.html">Home</a></li>
                <li> <a href="listing.html">All posts</a></li>

              </ul>
          </nav>

    </div>


    <div class="post-header">
        <h1 class="title">Imporant Code</h1>
        <div class="meta">Updated at: 22 May 2019 07:00:39</div>
    </div>
    <div class="markdown">

          

<p>Why do you want to work at Google?
 - Google is a successful company.
 - Learn what makes these companies successful (from a technical perspective) and how they work.
     -If you donâ€™t see early on what structure does look like - it will be hard to set goals later on.
 - Technically challenging, and I think it would be nice to understand how engineering teams work in a company as large as google.</p>

<h1>Tell me about yourself</h1>

<p>I like coding and thinking logically. I actually came from a research orientated background.
I like both the idea of pushing the boundaries of what I know, and I also like making things.</p>

<p>I started to realise I like forming actual real ideas into code, more than I like the research ideas.</p>

<p>In my spare time, I read books, exercise.</p>

<h1>Iterator for tree</h1>

<pre><code>def iterator(node):
    if node is None:
        return
    yield from iterator(node.left)
    yield node.val
    yield from iterator(node.right)
</code></pre>

<h1>Prefix sum</h1>

<pre><code>P = [0]
for x in A:
    P.append(P[-1] + x)
</code></pre>

<h1>Binary search (Duplicates)</h1>

<pre><code>	low = 0
	high = len(nums)-1
	index = -1
	while low &lt;= high:
			mid = (high + low) // 2
			if nums[mid] == target and (mid == 0 or nums[mid-1] != target):
					index = mid
					break
			elif target &gt; nums[mid]:
					low = mid + 1
			else:
					high = mid - 1
</code></pre>

<p>#Insert left bound binary search/right bound binary search</p>

<h1>Merge sort</h1>

<p>Requires extra memory
Stable</p>

<pre><code>def mergeSort(alist):
    print(&quot;Splitting &quot;,alist)
    if len(alist)&gt;1:
        mid = len(alist)//2
        lefthalf = alist[:mid]
        righthalf = alist[mid:]

        mergeSort(lefthalf)
        mergeSort(righthalf)

        i=0
        j=0
        k=0
        while i &lt; len(lefthalf) and j &lt; len(righthalf):
            if lefthalf[i] &lt; righthalf[j]:
                alist[k]=lefthalf[i]
                i=i+1
            else:
                alist[k]=righthalf[j]
                j=j+1
            k=k+1

        while i &lt; len(lefthalf):
            alist[k]=lefthalf[i]
            i=i+1
            k=k+1

        while j &lt; len(righthalf):
            alist[k]=righthalf[j]
            j=j+1
            k=k+1
    print(&quot;Merging &quot;,alist)
</code></pre>

<h1>Quick sort</h1>

<p>In-place
Not stable</p>

<pre><code>def quickSort(alist):
   quickSortHelper(alist,0,len(alist)-1)

def quickSortHelper(alist,first,last):
   if first&lt;last:

       splitpoint = partition(alist,first,last)

       quickSortHelper(alist,first,splitpoint-1)
       quickSortHelper(alist,splitpoint+1,last)


def partition(alist,first,last):
   p = alist[first]

   m = first
   for k in range(first+1, last+1):
      if (alist[k] &lt; p):
          m += 1
          swap(a,k,m)
   swap(a,i,m)
   return m

</code></pre>

<p><img src="/Users/anton/Documents/BrainDump/Algorithms/sorting_complexity.png" alt="alt text" /></p>

<h1>Heapify</h1>

<pre><code>def percUp(self,i):
    while i // 2 &gt; 0:
      if self.heapList[i] &lt; self.heapList[i // 2]:
         tmp = self.heapList[i // 2]
         self.heapList[i // 2] = self.heapList[i]
         self.heapList[i] = tmp
      i = i // 2


def percDown(self,i):
  while (i * 2) &lt;= self.currentSize:
      mc = self.minChild(i)
      if self.heapList[i] &gt; self.heapList[mc]:
          tmp = self.heapList[i]
          self.heapList[i] = self.heapList[mc]
          self.heapList[mc] = tmp
      i = mc


</code></pre>

<h1>Successor</h1>

<pre><code>def inOrderSuccessor(root, n):

    # Step 1 of the above algorithm
    if n.right is not None:
        return minValue(n.right)

    # Step 2 of the above algorithm
    p = n.parent
    while( p is not None):
        if n != p.right :
            break
        n = p  
        p = p.parent
    return p
</code></pre>

<h1>Bits</h1>

<pre><code>def getBit(num, i):
    return ((num&amp;1&lt;&lt;i))

def setBit(num,i):
    return num | i &lt;&lt; i
def clearBit(num,i):
    mask = ~(i&lt;&lt;i)
    return num &amp; mask

</code></pre>

<h1>Permutation / Combination</h1>

<pre><code>from itertools import permutations, combination
# Permutation generates n!, combination does nCr

def all_perms(elements):
    if len(elements) &lt;=1:
        yield elements
    else:
        for perm in all_perms(elements[1:]):
            for i in range(len(elements)):
                # nb elements[0:1] works in both string and list contexts
                yield perm[:i] + elements[0:1] + perm[i:]


def combinations_by_subset(seq, r):
    if r:
        for i in xrange(r - 1, len(seq)):
            for cl in (list(c) for c in combinations_by_subset(seq[:i], r - 1)):
                cl.append(seq[i])
                yield tuple(cl)
    else:
        yield tuple()

        val set = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}

        val sets = {}

            val set = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}

            val sets = {}


result.add({})
for item in set:
    for set in result:
        result.add(set + item)

</code></pre>

<h1>NP-P Problems</h1>

<ol>
<li>Vertex Cover</li>
<li>3 SAT</li>
<li>Independent Set</li>
<li>Hamiltonian Path Decision Problem</li>
<li>0/1 Knapsack</li>
</ol>

<h1>UFDS</h1>

<p>x = FindSet(i)</p>

<p>y = FindSet(j)</p>

<p>if (x != y) // !IsSameSet(i, j)</p>

<pre><code>if rank[x] &gt; rank[y]

      p[y] = x;

        else p[x] = y;
</code></pre>


    </div>
</div>
    <div class="footer">
        by <a href="https://seanngpengnam.com">Sean Ng</a> | <a href="https://github.com/pengnam/BrainDump">source</a>
  </div>
  </body>
</html>
